% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MDS_GO_results_functions.R
\name{GO_dotplot_wrapper}
\alias{GO_dotplot_wrapper}
\title{Create gprofiler dotplots}
\usage{
GO_dotplot_wrapper(
  object,
  file_loc,
  target_ontology,
  top_n,
  custom_width = NULL,
  custom_height = NULL,
  return_plot = FALSE
)
}
\arguments{
\item{object}{A time series object}

\item{file_loc}{The location where the files are to be saved}

\item{target_ontology}{The targeted ontology ex: 'REAC' or 'GO:BP'}

\item{top_n}{The number of top GOs to plot per cluster}

\item{custom_width}{A custom value for the width of the plot}

\item{custom_height}{A custom value for the height of the plot}

\item{return_plot}{Boolean indicating if the plot should be returned}
}
\value{
if specified, the function will return the ggplot2 object for the dotplot
}
\description{
Wrapper function for the creation of a dotplot which summarises the gprofiler findings
for a specified ontology.

The function reads the results for a location. It will automatically search for the
'gprofiler_results/data_files' folder in the procided location. This is should be located
in the TS_results folder, but can change based on the user.

The function will attempt to create the plot with proper width and height,
but these can be over-written by providing them to the function.

The function will save the plot in the location provided through the
gpro_file_location parameter.
}
\examples{
TS_object<-create_example_object_for_R()
TS_object <- normalize_timeSeries_with_deseq2(time_object=TS_object)
#Perform conditional differential gene expression analysis
TS_object<-conditional_DE_wrapper(TS_object,vignette_run=TRUE)
TS_object<-temporal_DE_wrapper(TS_object,do_all_combinations=TRUE,vignette_run=TRUE)
#Extract genes for PART clustering based on defined log(2)foldChange threshold
signi_genes<-select_genes_with_l2fc(TS_object)

#Use all samples, but implement a custom order. In this case it is reversed
sample_data<-exp_sample_data(TS_object)
TS_groups<-slot(TS_object,'group_names')
samps_2<-sample_data$sample[sample_data$group==TS_groups[2]]
samps_1<-sample_data$sample[sample_data$group==TS_groups[1]]

#Create the matrix that will be used for PART clustering
TS_object<-prep_counts_for_PART(object=TS_object,target_genes=signi_genes,scale=TRUE,target_samples=c(samps_2,samps_1))
TS_object<-compute_PART(TS_object,part_recursion=10,part_min_clust=10,dist_param="euclidean", hclust_param="average",vignette_run=TRUE)
TS_object<-run_gprofiler_PART_clusters(TS_object,vignette_run=TRUE) #Run the gprofiler analysis
#Set to NULL to not save results
gpro_res<-gprofiler_cluster_analysis(TS_object,'GO:BP',save_path=NULL)
gpro_dotplot<-GO_dotplot_wrapper(TS_object,file_loc=NULL,target_ontology='GO:BP',top_n=10,return_plot=TRUE)

}
